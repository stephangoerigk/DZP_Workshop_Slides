<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Einheit 1</title>
    <meta charset="utf-8" />
    <meta name="author" content="Dr. Stephan Goerigk" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/hygge.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <script src="libs/fabric/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#00C1BF"],"pen_size":4,"eraser_size":40,"palette":[]}) })</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




name: Title slide
class: middle, left
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
# DZPG-Workshop - Methoden der Psychotherapieforschung

### Nachmittagssession - Innovative analysis of existing RCT data
##### 19.11.2022 | Dr. phil. Stephan Goerigk

---
class: top, left
name: Contact Slide

### Kontakt

.pull-left[
Dr. phil. Stephan Goerigk 

Psychologische Methodenlehre

Klinik für Psychiatrie und Psychotherapie

Ludwig-Maximilians-Universität

Nussbaumstraße 7 · 80336 München · 

[stephan.goerigk@med.uni-muenchen.de](mailto:stephan.goerigk@med.uni-muenchen.de)

[Publikationen](https://scholar.google.at/citations?user=nlvO-e4AAAAJ&amp;hl=de)

[Commitment to Research Transparency](http://www.researchtransparency.org)
]

.pull-right[
.center[
&lt;br&gt;&lt;br&gt;&lt;br&gt;
.bottom[![](rtransperency.png)]
]
]

---
class: top, left
### Parallelgruppen-Design

#### Gold-Standard Wirksamkeitsanalyse (Efficacy)

.center[
&lt;img src="bilder/RCT.png" width="1000px" /&gt;
]

---
class: top, left
### Parallelgruppen-Design

#### Gold-Standard Wirksamkeitsanalyse (Efficacy)



.pull-left[
&lt;img src="Folien_files/figure-html/unnamed-chunk-3-1.png" width="400px" /&gt;
]

.pull-right[

```r
lmer(y ~ t * group + (1|id), data = df)
```

* Modellierung im linear mixed model (LMM)

* hierarchische Datenstruktur berücksichtigt (measurements nested within patients)

* Schätzung einer Durschnittsrate (Slope) für die Response der Gruppen

* Wirksamkeitsnachweis i.d.R. definiert durch Differenz in Gruppenslopes bis Endpunkt
(Zeit x Gruppe Interaktion)
]

---
class: top, left
### Parallelgruppen-Design

#### Gold-Standard Wirksamkeitsanalyse (Efficacy)


```r
lmer(y ~ t * group + (1|id), data = df)
```


```
##                Estimate Std. Error       df t value Pr(&gt;|t|)
## (Intercept)      27.812      0.943  201.121  29.493    0.000
## t                -1.263      0.065 1348.000 -19.447    0.000
## groupplacebo     -2.390      1.334  201.121  -1.792    0.075
## t:groupplacebo    1.296      0.092 1348.000  14.109    0.000
```

* signifikante Überlegenheit der aktiven gegenüber Placebogruppe

* ABER: nur auf Gruppenebene (nicht alle Patienten zeigen ein Theraieansprechen)

**Vorsicht bei der Interpretation:**

* i.d.R. heterogene Therapieresponse

`\(\rightarrow\)` Aufschlüsselung der Heterogenität Zielsetzung des **Präzisionsansatzes**

---
class: top, left
### Parallelgruppen-Design 

#### Präzisionsmedizinische Fragestellung

.center[
&lt;img src="bilder/precision.png" width="1000px" /&gt;
]

---
class: top, left
### Responderanalyse 

#### Marker für Behandlungserfolg - Klassische Explanative Ansätze der Responderanalyse

.pull-left[
.center[
&lt;img src="bilder/mod1.png" width="400px" /&gt;
]

.center[
&lt;img src="bilder/Moderation.png" width="400px" /&gt;
]
]

.pull-right[

**Ansatz: **

* assoziative Responderanalyse

* hohe Zahl von Moderationskandidaten unterschiedlicher Modalitäten (Verhalten, Biomarker...)

**ABER:**

* bislang wenig Anhaltpunkte für stratifizierte Behandlungsplanung

* wenig Replikation von Ergebnissen
]

.center[

```r
lmer(y ~ t * group * moderator + (1|id), data = df)
glm(response ~ group * moderator, data = df, family = binomial)
```
]

---
class: top, left
### Responderanalyse 

#### Marker für Behandlungserfolg - Ansätze zur Erhöhung der Präzision

.pull-left[
.center[
&lt;img src="bilder/mod3.png" width="500px" /&gt;
]
.center[
&lt;img src="bilder/mod2.png" width="500px" /&gt;
]
]

.pull-right[
**Optimierung der Prädiktion:**
* Hinzunahme von Prädiktoren
* Bessere Messungen
* Leistungsfähigere Modelle
* Modellierung von Wechselwirkungen
* Non-lineare Modellierung
* Hierarchische Modellierung

**Optimierung der Outcomes:**
* Differenzierte (multidimensionale) Outcomes
* Dynamische Outcomes
* Hochauflösende Outcomes (Zeitreihen)
* Reziproke Outcomes (Wechselwirkungen)
* Vernetzte Outcomes
]

---
class: top, left
### Responderanalyse 

#### Probleme gängiger Outcomes von Wirksamkeitsstudien

* Summenwerte

* Arbitäre Cutoffs

* Keine Informationen über unterschiedliches Timing im Therapieansprechen

* Gruppenbasierte Durchschnittsverläufe

* oft zu geringe zeitliche Auflösung für schwankende Phänomene

* Keine objektiven Verhaltensmaße

* Wechselwirkungen auf Symptombasis nicht berücksichtigt

---
class: top, left
### Units of Analysis

#### Problem 1: Summenwerte

.pull-left[

.center[
&lt;img src="bilder/dep1.png" width="700px" /&gt;
]
.pull-left[
.center[
&lt;img src="bilder/sum.png" width="200px" /&gt;
]
]
.pull-right[
.center[
&lt;br&gt;
&lt;img src="bilder/gif1.gif" width="800px" /&gt;
]
]
]

.pull-right[
.center[
&lt;img src="bilder/sideeffects.png" width="400px" /&gt;
]

* alle Symptome gehen gleichgewichtet ein (tau-Äquivalenz)

* Ignorieren behandlungsspezifischer Effekte
]

---
class: top, left
### Units of Analysis

#### Problem 1: Summenwerte

.pull-left[
.pull-left[
.center[
&lt;br&gt;
&lt;img src="bilder/sum.png" width="200px" /&gt;
]
]
.pull-right[
.center[
&lt;br&gt;&lt;br&gt;
&lt;img src="bilder/gif1.gif" width="800px" /&gt;
]
]
]

.pull-right[
.center[
&lt;img src="bilder/item.gif" width="400px" /&gt;
]
]

**Problem:**
* Symptome verbessern sich ggf. mit unterschiedlicher Intensität

* Schlecht ansprechende Symptome maskieren ggf. Verbesserung gut ansprechender Symptome
---
class: top, left
### Units of Analysis

#### Lösungsansatz: Symptomcluster

.pull-left[
.pull-left[
.center[
&lt;img src="bilder/sum.png" width="200px" /&gt;
]
.center[
&lt;img src="bilder/symptomcluster1.png" width="200px" /&gt;
]
]
.pull-right[
.center[
&lt;br&gt;
&lt;img src="bilder/gif1.gif" width="800px" /&gt;
]
.center[
&lt;br&gt;&lt;br&gt;
&lt;img src="bilder/gif2.gif" width="800px" /&gt;
]
]
]

.pull-right[
.center[
&lt;img src="bilder/symptomcluster.png" width="400px" /&gt;
]
.center[
&lt;img src="bilder/symptomcluster3.png" width="400px" /&gt;
]
]

---
class: top, left
### Units of Analysis

#### Symptomcluster



Beispieldatensatz:


```r
head(data_cluster, 2)
```

```
##   Item1 Item2 Item3 Item4 Item5 Item6 Item7 Item8 Item9 Item10
## 1  2.95  2.19  2.48  3.97  0.99  1.41  2.17  2.15  0.49   3.50
## 2  3.06  3.83  3.65  2.31  2.90  1.72  0.93 -0.52  0.51   1.58
```

Beispielcode:


```r
# Transpose data
data_transposed = t(na.omit(data_cluster))
# Compute distance matrix
d = dist(data_transposed, method = "euclidean")
# Clustering
clust = hclust(d, method = "ward.D2")
# Create dendrogram
dend &lt;- as.dendrogram(clust, hang = -1)
# Prune dendrogram
pruned = dynamicTreeCut::cutreeDynamic(clust, distM = as.matrix(d), method = "hybrid", minClusterSize = 1)
```
---
class: top, left
### Units of Analysis

#### Symptomcluster: Beispielstudie (Goerigk et al., 2021)

.center[
&lt;img src="bilder/Fig1.png" width="950px" /&gt;
]

---
class: top, left
### Units of Analysis

#### Problem 2: Arbitäre Cutoffs

.pull-left[
.center[
&lt;img src="bilder/gif1.gif" width="450px" /&gt;
]
]
.pull-right[
.center[
&lt;img src="bilder/respgif.gif" width="700px" /&gt;
]
]

* feste Definitionen für Behandlungserfolg z.B. Response `\(\geq\)` 50% Symptomreduktion

* Vorteil: ermöglicht leicht interpretierbare Subgruppenanalyse (Responder vs. Non-Responder)

---
class: top, left
### Units of Analysis

#### Problem 2: Arbitäre Cutoffs

.pull-left[
.center[
&lt;img src="bilder/respgif.gif" width="700px" /&gt;
]
]
.pull-right[
.center[
&lt;img src="bilder/resp.png" width="300px" /&gt;
]
]

* Nachteil: Cutoff ist arbiträr `\(\rightarrow\)` `\(\geq\)` 50% Symptomreduktion klinisch relevant?

* Nachteil: 49% Verbessung und 50% Verbessung unterschiedliche Kategorie; 50% und 99% gleich

---
class: top, left
### Units of Analysis

#### Problem 3: Keine Informationen über unterschiedliches Timing im Therapieansprechen

.pull-left[
.center[
&lt;img src="bilder/RCT2.png" width="700px" /&gt;
]
]
.pull-right[
.center[
&lt;img src="bilder/Timing.gif" width="700px" /&gt;
]
]

* Wirksamkeitsvergleich und Berechnung von Responderstatus i.d.R. zum **Endpunkt** der Studie
* Ignorieren **frühen/späten** Therapieansprechens
* Keine Berücksichtigung der **Dynamik** von Subgruppen

---
class: top, left
### Units of Analysis

#### Lösungsansatz: Response-Trajektorien im Mixture Modell

.pull-left[
1-Trajektorien-Ansatz
.center[
&lt;img src="bilder/gif4.gif" width="250px" /&gt;
]
Mixture-Modell
.center[
&lt;img src="bilder/gif5.gif" width="250px" /&gt;
]
]

.pull-right[
Durchschnittstrajektorie
.center[
&lt;img src="bilder/gif1.gif" width="250px" /&gt;
]
Durchschnittstrajektorie
.center[
&lt;img src="bilder/gif3.gif" width="250px" /&gt;
]
]

---
class: top, left
### Units of Analysis

#### Lösungsansatz: Response-Trajektorien im Mixture Modell



.pull-left[
Beispieldatensatz:


```r
head(df, 10)
```

```
##    t id        y
## 1  1  1 25.40166
## 2  2  1 25.57062
## 3  3  1 15.93133
## 4  1  2 24.38786
## 5  2  2 22.21372
## 6  3  2 14.39663
## 7  1  3 26.84166
## 8  2  3 16.81819
## 9  3  3 26.07055
## 10 1  4 32.17944
```
]

.pull-left[
Beispielcode:


```r
mi = lcmm::hlme(fixed = y ~ 1 + t + I(t^2),
           mixture = ~ 1 + t + I(t^2),
           random = ~ 1,
           ng = 5,
           nwg = FALSE,
           idiag = FALSE,
           data = df,
           subject = "id")
```
]

---
class: top, left
### Units of Analysis

#### Response-Trajektorien: Beispielstudie (Goerigk et al. in prep)

.center[
&lt;img src="bilder/Figure1_alternate.png" width="1000px" /&gt;
]

---
class: top, left
### Units of Analysis

#### Problem 5: Niedrige zeitliche Auflösung bei schwankenden Konstrukten

.pull-left[

* Endpunkt-Messung stark Timing-abhängig

* Besondere Bedeutung bei BL-Prädiktoren

* Zeitfenster vs. Zeitpunkt

**Fortschritt:**

* EMA-Daten und Sensing ermöglichen zeitlich-verdichtete Messungen

* Probleme: 

  * große Datenmengen
  * wenig inferenzstatistische Konzepte
  * Power-Überlegungen

]
.pull-right[
.center[
&lt;img src="Folien_files/figure-html/unnamed-chunk-44-1.png" width="400px" /&gt;
]
]

---
class: top, left
### Units of Analysis

#### Lösungsansatz: Time-Series Modeling - Dynamic Time Warping

.pull-left[
.center[
&lt;img src="bilder/dtw1.png" width="500px" /&gt;
]
]

.pull-right[
.center[
&lt;img src="bilder/dtw2.png" width="500px" /&gt;
]
]

---
class: top, left
### Units of Analysis

#### Time-Series Modeling - Dynamic Time Warping

**Vorteile:**

* Time-series clustering Ansatz

* Reduktion der Komplexität hoch-aufgelöster Zeitreihendaten

* Zeitreihen können gruppiert werden, selbst wenn diese nicht in Form und Muster synchron sind (lagged)

* Flexibel modifizierbar, je nach gewünschtem Clustering Algorithmus (Hierachical, Centroid-based...)

---
class: top, left
### Units of Analysis

#### Time-Series Modeling - Dynamic Time Warping



Beispieldatensatz:


```r
head(ts_sim_df, 3)
```

```
##   nodep_V1 nodep_V2 nodep_V3 nodep_V4 nodep_V5   dep_V1   dep_V2   dep_V3   dep_V4   dep_V5
## 1 6.202435 6.671782 6.487326 5.313489 6.876857 5.534393 5.047133 6.245207 5.580423 8.969506
## 2 6.600054 5.266929 6.717761 6.080898 6.212038 5.643375 5.726632 6.326248 5.735229 8.453706
## 3 6.810013 6.798338 5.601576 6.172589 5.288736 5.676489 5.774688 6.038278 5.755343 9.473045
```

Beispielcode:


```r
dtwclust::tsclust(t(ts_sim_df),
                  type = "h",
                  k = 2,
                  distance = "dtw",
                  control = hierarchical_control(method = "complete"),
                  preproc = NULL,
                  args = tsclust_args(dist = list(window.size = 5L)))
```

---
class: top, left
### Units of Analysis

#### Time-Series Modeling - Dynamic Time Warping

.center[
&lt;img src="bilder/dtw4.png" width="900px" /&gt;
]

---
class: top, left
### Multivariate pattern

#### Strukturgleichungsmodelle:

.center[
&lt;img src="bilder/sem.png" width="1000px" /&gt;
]

---
class: top, left
### Multivariate pattern

#### Strukturgleichungsmodelle:

.center[
&lt;img src="bilder/semm.png" width="900px" /&gt;
]

---
class: top, left
### Multivariate pattern

#### Strukturgleichungsmodelle: Latent-Growth Curve

.center[
&lt;img src="bilder/lgcm.png" width="500px" /&gt;
]

* Abbilden des Slopes als latente Variable (mit Varianz -&gt; Random Effekt)

* Kann mit komplexen Messmodellen und multivariaten Analysen kombiniert werden

---
class: top, left
### Multivariate pattern

#### Strukturgleichungsmodelle: Latent-Growth Curve

.pull-left[
Beispieldatensatz:




```r
library(lavaan)
head(data, 4)
```

```
##      t1    t2    t3    t4    t5
## 1  1.73  2.14  2.77  2.52  2.52
## 2 -1.98 -4.40 -6.02 -7.03 -7.03
## 3  0.32 -1.27  1.56  2.87  2.87
## 4  0.78  3.53  3.14  5.36  5.36
```

Beispielcode:


```r
model &lt;- ' i =~ 1*t1 + 1*t2 + 1*t3 + 1*t4 + 1*t5
           s =~ 0*t1 + 1*t2 + 2*t3 + 3*t4 + 4*t5'
fit &lt;- lavaan::growth(model, data = data)
summary(fit)
```
]

.pull-right[
.center[
&lt;img src="bilder/lgcm.png" width="500px" /&gt;
]
]
---
class: top, left
### Multivariate pattern

#### Strukturgleichungsmodelle: Latent-Growth Mediation

.center[
&lt;img src="bilder/sem1.png" width="500px" /&gt;
]

---
class: top, left
### Multivariate pattern

#### Strukturgleichungsmodelle: Latent-Growth Mediation

Beispielcode:

.pull-left[

```r
model &lt;- '
iy =~ 1*y1 + 1*y2 + 1*y3 + 1*y4
sy =~ 0*y1 + 1*y2 + 2*y3 + 3*y4
ix =~ 1*x1 + 1*x2 + 1*x3 + 1*x4
sx =~ 0*x1 + 1*x2 + 2*x3 + 3*x4
im =~ 1*m1 + 1*m2 + 1*m3 + 1*m4
sm =~ 0*m1 + 1*m2 + 2*m3 + 3*m4

# direct effect
sy ~ c*sx
# mediator
sm ~ a*sx
sy ~ b*sm
# indirect effect (a*b)
ab := a*b
# total effect
total := c + (a*b)'
fit &lt;- lavaan::sem(model, data = Data)
```
]
.pull-right[
.center[
&lt;img src="bilder/sem1.png" width="500px" /&gt;
]
]

---
class: top, left
### Multivariate pattern

#### Strukturgleichungsmodelle: Cross-lagged panel model

.center[
&lt;img src="bilder/sem2.png" width="700px" /&gt;
]

---
class: top, left
### Multivariate pattern

#### Strukturgleichungsmodelle: Cross-lagged panel model

Beispielcode:

.pull-left[

```r
cl_model = "
Cog_T4 ~ Cog_T3 + Func_T3
Func_T4 ~ Cog_T3 + Func_T3
Cog_T3 ~ Cog_T2 + Func_T2
Func_T3 ~ Cog_T2 + Func_T2
Cog_T2 ~ Cog_T1 + Func_T1
Func_T2 ~ Cog_T1 + Func_T1
Cog_T4 ~~ Func_T4
Cog_T3 ~~ Func_T3
Cog_T2 ~~ Func_T2
Cog_T1 ~~ Func_T1
"

fit &lt;-lavaan::sem(cl_model, missing = "fiml", data = data)
summary(fit)
```
]
.pull-right[
.center[
&lt;img src="bilder/sem2.png" width="500px" /&gt;
]
]

---
class: top, left
### Multivariate pattern

#### Netzwerkanalyse

.center[
&lt;img src="bilder/nets.png" width="1000px" /&gt;
]

* Analyse psychischer Phänomene auf dem Systemlevel

* Exploration hoch dimensionaler Daten ohne theoretische Vorannahmen (wie EFA, o.ä.)

* Besonderheit: paarweise Abhängigkeiten (pairwise conditional dependencies, PCD)

* PCD = probabilistisch abhängig konditional auf alle andere Variablen 

* joint probability distribution (graphical model - pairwise Markov random field, PMRF)

---
class: top, left
### Multivariate pattern

#### Netzwerkanalyse

.pull-left[
.center[
&lt;img src="bilder/network1.png" width="500px" /&gt;
]
]

.pull-right[
* node selection: eher inhaltlich als methodisch

* edge selection methods (PMRF creation): 

  * fit indices
  * significance testing
  * cross-validation
  * regularized estimation (LASSO)
  
* node centrality:

  * node strength (sum of absolute edge weights of edges per node)
  * closeness (distance between the node and all other nodes)
  * betweenness (how often a node lies on the shortest path connecting two other nodes)
]
---
class: top, left
### Multivariate pattern

#### Netzwerkanalyse

.center[
&lt;img src="bilder/network2.png" width="700px" /&gt;
]

---
class: top, left
### Multivariate pattern

#### Netzwerkanalyse

.center[
&lt;img src="bilder/network3.png" width="500px" /&gt;
]

---
class: top, left
### Multivariate pattern

#### Netzwerkanalyse

**Beispielcode:**


```r
res &lt;- mlVAR(data_detrended,
             vars=varLabs,
             idvar="id",
             dayvar="day",
             beepvar="beep",
             lags = 1,
             temporal = "orthogonal",
             contemporaneous = "orthogonal",
             nCores = 8)

# Get networks:
cont &lt;- getNet(res, "contemporaneous", layout = "spring", nonsig = "hide", rule = "and")
bet  &lt;- getNet(res, "between", nonsig = "hide", rule = "and")
temp &lt;- getNet(res, "temporal", nonsig = "hide")
```


---
class: top, left
### Cross-validated prediction

#### Explanative vs. Prädiktive Perspektive

.pull-left[
.center[
&lt;img src="bilder/ml.png" width="500px" /&gt;
]
]

.pull-right[
* Besprochene Outcomes lassen sich **prädizieren**

* Fortschritte durch komplexe Modellierungsmethoden (Machine Learning)

* Modelle erlauben Verarbeitung hochdimensionaler Daten (**Hyperparametertuning** erforderlich)

* Hoher **inkrementeller Nutzen** wegen Inkludierbarkeit in klinische Entscheidungsfindung

* Fortschritte in Interpretierbarkeit durch **IML** Methoden
]


---
class: top, left
### Cross-validated prediction

#### Explanative vs. Prädiktive Perspektive

.pull-left[
.center[
&lt;img src="bilder/ml2.png" width="250px" /&gt;
]
]
.pull-right[
**Explanative Analyse:**

* **Kriterium:** statistische Hypothesentests (p-Wert) und Effektstärken

* i.d.R. **gruppenbasierte** Durchschnittsschätzungen

* hoher **exploratorischer** Gehalt, i.d.R. leicht interpretierbare Modelle

**Prädiktive Analyse:**

* Vorhersage auf **Einzelpatientenebene**

* **Kriterium:** Vorhersagegenauigkeit

* **Notwendig:** Kreuzvalidierung anhand von Testdaten
]

---
class: top, left
### Cross-validated prediction

#### Use-Case und Relevanz der Kreuzvalidierung

.center[
&lt;img src="bilder/ML 2.png" width="900px" /&gt;
]

---
class: top, left
### Cross-validated prediction

#### Beispielcode: Random-Forest Learner mit Repeated Nested CV


```r
task_repCV = makeRegrTask(id = "task", target = "HAM-A", data = data)
ctrl = makeTuneControlRandom(maxit = 250L)

rf.parset = makeParamSet(
  makeIntegerParam("mtry", lower = 1L, upper = 10L),
  makeIntegerParam("ntree", lower = 100L, upper = 5000L),
  makeIntegerParam("nodesize", lower = 1L, upper = 10L))

rf = makeImputeWrapper(makeDummyFeaturesWrapper(makeLearner("regr.randomForest"))
                       
inner_RepCV = makeResampleDesc(method = "RepCV")
rdesc_RepCV = makeResampleDesc(method = "RepCV")

my_measures = list(rmse, spearmanrho)

rf_RepCV = makeTuneWrapper(rf, par.set = rf.parset, resampling = inner_RepCV, control = ctrl, measures = my_measures)

rinst_RepCV = makeResampleInstance(rdesc_RepCV, task_repCV)

res = resample(learner = rf_lso, task = task_repCV, resampling = rinst_RepCV, measures = my_measures)
```


---
class: top, left
### Take-aways

.full-width[.content-box-gray[
* RCTs sind essentielle Experimente zur Wirksamkeitsüberprüfung von Therapien und als solche nicht zu ersetzen

* Ziel von Re-Analysen: Aufschlüsseln von Heterogenität im Therapieansprechen (Tailored Treatments)

* Aus Wirksamkeitsanalysen abgeleitete Maße haben konzeptuelle Schwächen bzgl. Erklärung der Heterogenität 

* Analyse von Summenscores vs. separate Analyse von Symtptomsystemen

* Analyse von querschnittlicher Response/Remission vs. dynamische Verlaufsklassen  

* stationäre Messungen vs. Zeitreihen und Zeitreihenanalyse

* Störungsmodellierung als Schweregradseinschätzung/kategoriale Diagnose vs. auf dem Systemlevel (Netzwerke)

* Explanative Modellierung vs. Prädiktive Modellierung (oder Kombination)
]
]

[**Link zur Wissensüberprüfung**](https://docs.google.com/forms/d/e/1FAIpQLSfAAWpZWqxU4Bw5LzVFRtYo7RvCIt4BRAEWCHx6XvlePfEQzw/viewform?usp=sf_link)

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current%",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
